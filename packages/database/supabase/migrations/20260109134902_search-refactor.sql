-- =============================================================================
-- Global Search Architecture Refactor
-- Migrate from single-table multi-tenant search to table-per-company design
-- =============================================================================

-- =============================================================================
-- PART 0: Drop Old Triggers and Functions FIRST
-- =============================================================================

-- Employee triggers
DROP TRIGGER IF EXISTS create_employee_search_result ON "employee";
DROP TRIGGER IF EXISTS update_employee_search_result ON "user";

-- Customer triggers
DROP TRIGGER IF EXISTS create_customer_search_result ON "customer";
DROP TRIGGER IF EXISTS update_customer_search_result ON "customer";

-- Supplier triggers
DROP TRIGGER IF EXISTS create_supplier_search_result ON "supplier";
DROP TRIGGER IF EXISTS update_supplier_search_result ON "supplier";

-- Item triggers
DROP TRIGGER IF EXISTS create_item_search_result ON "item";
DROP TRIGGER IF EXISTS update_item_search_result ON "item";
DROP TRIGGER IF EXISTS delete_item_search_result ON "item";

-- Equipment Type triggers
DROP TRIGGER IF EXISTS create_equipment_type_search_result ON "equipmentType";
DROP TRIGGER IF EXISTS update_equipment_type_search_result ON "equipmentType";
DROP TRIGGER IF EXISTS delete_equipment_type_search_result ON "equipmentType";

-- Work Cell Type triggers
DROP TRIGGER IF EXISTS create_work_cell_type_search_result ON "workCellType";
DROP TRIGGER IF EXISTS update_work_cell_type_search_result ON "workCellType";
DROP TRIGGER IF EXISTS delete_work_cell_type_search_result ON "workCellType";

-- Drop old functions
DROP FUNCTION IF EXISTS create_employee_search_result();
DROP FUNCTION IF EXISTS update_employee_search_result();
DROP FUNCTION IF EXISTS create_customer_search_result();
DROP FUNCTION IF EXISTS update_customer_search_result();
DROP FUNCTION IF EXISTS create_supplier_search_result();
DROP FUNCTION IF EXISTS update_supplier_search_result();
DROP FUNCTION IF EXISTS create_item_search_result();
DROP FUNCTION IF EXISTS update_item_search_result();
DROP FUNCTION IF EXISTS delete_item_search_result();
DROP FUNCTION IF EXISTS create_equipment_type_search_result();
DROP FUNCTION IF EXISTS update_equipment_type_search_result();
DROP FUNCTION IF EXISTS delete_equipment_type_search_result();
DROP FUNCTION IF EXISTS create_work_cell_type_search_result();
DROP FUNCTION IF EXISTS update_work_cell_type_search_result();
DROP FUNCTION IF EXISTS delete_work_cell_type_search_result();

-- Drop old table and type
DROP TABLE IF EXISTS "search";
DROP TYPE IF EXISTS "searchEntity";

-- =============================================================================
-- PART 1: Create Registry Table
-- =============================================================================

CREATE TABLE "searchIndexRegistry" (
  "companyId" TEXT NOT NULL PRIMARY KEY,
  "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  "lastRebuiltAt" TIMESTAMP WITH TIME ZONE,
  CONSTRAINT "searchIndexRegistry_companyId_fkey"
    FOREIGN KEY ("companyId") REFERENCES "company"("id") ON DELETE CASCADE ON UPDATE CASCADE
);

-- =============================================================================
-- PART 2: Create Table Creation Function
-- =============================================================================

CREATE OR REPLACE FUNCTION create_company_search_index(p_company_id TEXT)
RETURNS VOID AS $$
DECLARE
  v_table_name TEXT;
BEGIN
  v_table_name := 'searchIndex_' || p_company_id;

  -- Create the search index table
  EXECUTE format('
    CREATE TABLE IF NOT EXISTS %I (
      "id" BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
      "entityType" TEXT NOT NULL,
      "entityId" TEXT NOT NULL,
      "title" TEXT NOT NULL,
      "description" TEXT DEFAULT '''',
      "link" TEXT NOT NULL,
      "tags" TEXT[] DEFAULT ''{}'',
      "metadata" JSONB DEFAULT ''{}'',
      "searchVector" TSVECTOR GENERATED ALWAYS AS (
        to_tsvector(''english'',
          COALESCE(title, '''') || '' '' ||
          COALESCE(description, '''') || '' '' ||
          COALESCE(array_to_string(tags, '' ''), '''')
        )
      ) STORED,
      "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
      "updatedAt" TIMESTAMP WITH TIME ZONE,
      CONSTRAINT %I UNIQUE ("entityType", "entityId")
    )', v_table_name, v_table_name || '_entity_unique');

  -- Create indexes
  EXECUTE format('CREATE INDEX IF NOT EXISTS %I ON %I USING GIN ("searchVector")',
    v_table_name || '_fts_idx', v_table_name);
  EXECUTE format('CREATE INDEX IF NOT EXISTS %I ON %I ("entityType")',
    v_table_name || '_entityType_idx', v_table_name);
  EXECUTE format('CREATE INDEX IF NOT EXISTS %I ON %I ("updatedAt" DESC)',
    v_table_name || '_updatedAt_idx', v_table_name);

  -- Enable RLS (no SELECT policies - access via service role bypass)
  EXECUTE format('ALTER TABLE %I ENABLE ROW LEVEL SECURITY', v_table_name);

  -- Register the company in the registry
  INSERT INTO "searchIndexRegistry" ("companyId")
  VALUES (p_company_id)
  ON CONFLICT ("companyId") DO NOTHING;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================================================
-- PART 3: Create Company Trigger (auto-create search index for new companies)
-- =============================================================================

CREATE OR REPLACE FUNCTION on_company_created_search_index()
RETURNS TRIGGER AS $$
BEGIN
  PERFORM create_company_search_index(NEW.id);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER company_search_index_trigger
  AFTER INSERT ON "company"
  FOR EACH ROW EXECUTE FUNCTION on_company_created_search_index();

-- =============================================================================
-- PART 4: Create Sync Functions
-- =============================================================================

-- -----------------------------------------------------------------------------
-- 4.1 Employee Sync
-- -----------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION sync_employee_to_search_index()
RETURNS TRIGGER AS $$
DECLARE
  v_table_name TEXT;
  v_emp_name TEXT;
  v_emp_type TEXT;
BEGIN
  IF TG_OP = 'DELETE' THEN
    v_table_name := 'searchIndex_' || OLD."companyId";
    EXECUTE format('DELETE FROM %I WHERE "entityType" = $1 AND "entityId" = $2', v_table_name)
      USING 'employee', OLD.id;
    RETURN OLD;
  END IF;

  v_table_name := 'searchIndex_' || NEW."companyId";

  -- Get employee name from user table
  SELECT "fullName" INTO v_emp_name FROM "user" WHERE id = NEW.id;

  -- Get employee type name
  SELECT name INTO v_emp_type FROM "employeeType" WHERE id = NEW."employeeTypeId";

  IF NEW.active = false THEN
    EXECUTE format('DELETE FROM %I WHERE "entityType" = $1 AND "entityId" = $2', v_table_name)
      USING 'employee', NEW.id;
    RETURN NEW;
  END IF;

  EXECUTE format('
    INSERT INTO %I ("entityType", "entityId", "title", "link", "tags", "metadata")
    VALUES ($1, $2, $3, $4, $5, $6)
    ON CONFLICT ("entityType", "entityId") DO UPDATE SET
      "title" = EXCLUDED."title",
      "tags" = EXCLUDED."tags",
      "metadata" = EXCLUDED."metadata",
      "updatedAt" = NOW()
  ', v_table_name) USING
    'employee',
    NEW.id,
    COALESCE(v_emp_name, ''),
    '/x/person/' || NEW.id,
    ARRAY_REMOVE(ARRAY[v_emp_type], NULL),
    jsonb_build_object('active', NEW.active);

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- -----------------------------------------------------------------------------
-- 4.2 Customer Sync
-- -----------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION sync_customer_to_search_index()
RETURNS TRIGGER AS $$
DECLARE
  v_table_name TEXT;
  v_cust_type TEXT;
  v_cust_status TEXT;
BEGIN
  IF TG_OP = 'DELETE' THEN
    v_table_name := 'searchIndex_' || OLD."companyId";
    EXECUTE format('DELETE FROM %I WHERE "entityType" = $1 AND "entityId" = $2', v_table_name)
      USING 'customer', OLD.id;
    RETURN OLD;
  END IF;

  v_table_name := 'searchIndex_' || NEW."companyId";

  SELECT name INTO v_cust_type FROM "customerType" WHERE id = NEW."customerTypeId";
  SELECT name INTO v_cust_status FROM "customerStatus" WHERE id = NEW."customerStatusId";

  EXECUTE format('
    INSERT INTO %I ("entityType", "entityId", "title", "link", "tags", "metadata")
    VALUES ($1, $2, $3, $4, $5, $6)
    ON CONFLICT ("entityType", "entityId") DO UPDATE SET
      "title" = EXCLUDED."title",
      "tags" = EXCLUDED."tags",
      "metadata" = EXCLUDED."metadata",
      "updatedAt" = NOW()
  ', v_table_name) USING
    'customer',
    NEW.id,
    NEW.name,
    '/x/customer/' || NEW.id,
    ARRAY_REMOVE(ARRAY[v_cust_type, v_cust_status], NULL),
    jsonb_build_object('taxId', NEW."taxId");

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- -----------------------------------------------------------------------------
-- 4.3 Supplier Sync
-- -----------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION sync_supplier_to_search_index()
RETURNS TRIGGER AS $$
DECLARE
  v_table_name TEXT;
  v_supp_type TEXT;
  v_supp_status TEXT;
BEGIN
  IF TG_OP = 'DELETE' THEN
    v_table_name := 'searchIndex_' || OLD."companyId";
    EXECUTE format('DELETE FROM %I WHERE "entityType" = $1 AND "entityId" = $2', v_table_name)
      USING 'supplier', OLD.id;
    RETURN OLD;
  END IF;

  v_table_name := 'searchIndex_' || NEW."companyId";

  SELECT name INTO v_supp_type FROM "supplierType" WHERE id = NEW."supplierTypeId";
  SELECT name INTO v_supp_status FROM "supplierStatus" WHERE id = NEW."supplierStatusId";

  EXECUTE format('
    INSERT INTO %I ("entityType", "entityId", "title", "link", "tags", "metadata")
    VALUES ($1, $2, $3, $4, $5, $6)
    ON CONFLICT ("entityType", "entityId") DO UPDATE SET
      "title" = EXCLUDED."title",
      "tags" = EXCLUDED."tags",
      "metadata" = EXCLUDED."metadata",
      "updatedAt" = NOW()
  ', v_table_name) USING
    'supplier',
    NEW.id,
    NEW.name,
    '/x/supplier/' || NEW.id,
    ARRAY_REMOVE(ARRAY[v_supp_type, v_supp_status], NULL),
    jsonb_build_object('taxId', NEW."taxId");

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- -----------------------------------------------------------------------------
-- 4.4 Item Sync
-- -----------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION sync_item_to_search_index()
RETURNS TRIGGER AS $$
DECLARE
  v_table_name TEXT;
  v_link TEXT;
BEGIN
  IF TG_OP = 'DELETE' THEN
    v_table_name := 'searchIndex_' || OLD."companyId";
    EXECUTE format('DELETE FROM %I WHERE "entityType" = $1 AND "entityId" = $2', v_table_name)
      USING 'item', OLD.id;
    RETURN OLD;
  END IF;

  v_table_name := 'searchIndex_' || NEW."companyId";

  -- Determine link based on item type
  v_link := CASE NEW.type
    WHEN 'Part' THEN '/x/part/' || NEW.id
    WHEN 'Service' THEN '/x/service/' || NEW.id
    WHEN 'Tool' THEN '/x/tool/' || NEW.id
    WHEN 'Consumable' THEN '/x/consumable/' || NEW.id
    WHEN 'Material' THEN '/x/material/' || NEW.id
    WHEN 'Fixture' THEN '/x/fixture/' || NEW.id
    ELSE '/x/part/' || NEW.id
  END;

  EXECUTE format('
    INSERT INTO %I ("entityType", "entityId", "title", "description", "link", "tags", "metadata")
    VALUES ($1, $2, $3, $4, $5, $6, $7)
    ON CONFLICT ("entityType", "entityId") DO UPDATE SET
      "title" = EXCLUDED."title",
      "description" = EXCLUDED."description",
      "link" = EXCLUDED."link",
      "tags" = EXCLUDED."tags",
      "metadata" = EXCLUDED."metadata",
      "updatedAt" = NOW()
  ', v_table_name) USING
    'item',
    NEW.id,
    NEW."readableId",
    NEW.name || ' ' || COALESCE(NEW.description, ''),
    v_link,
    ARRAY_REMOVE(ARRAY[NEW.type::TEXT, NEW."replenishmentSystem"::TEXT], NULL),
    jsonb_build_object('active', NEW.active, 'blocked', NEW.blocked);

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- -----------------------------------------------------------------------------
-- 4.5 Equipment Type Sync
-- -----------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION sync_equipment_type_to_search_index()
RETURNS TRIGGER AS $$
DECLARE
  v_table_name TEXT;
BEGIN
  IF TG_OP = 'DELETE' THEN
    v_table_name := 'searchIndex_' || OLD."companyId";
    EXECUTE format('DELETE FROM %I WHERE "entityType" = $1 AND "entityId" = $2', v_table_name)
      USING 'equipmentType', OLD.id;
    RETURN OLD;
  END IF;

  v_table_name := 'searchIndex_' || NEW."companyId";

  EXECUTE format('
    INSERT INTO %I ("entityType", "entityId", "title", "description", "link", "tags", "metadata")
    VALUES ($1, $2, $3, $4, $5, $6, $7)
    ON CONFLICT ("entityType", "entityId") DO UPDATE SET
      "title" = EXCLUDED."title",
      "description" = EXCLUDED."description",
      "tags" = EXCLUDED."tags",
      "metadata" = EXCLUDED."metadata",
      "updatedAt" = NOW()
  ', v_table_name) USING
    'equipmentType',
    NEW.id,
    NEW.name,
    COALESCE(NEW.description, ''),
    '/x/resources/equipment/' || NEW.id,
    ARRAY[CASE WHEN NEW.active THEN 'active' ELSE 'inactive' END],
    jsonb_build_object('setupHours', NEW."setupHours");

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- -----------------------------------------------------------------------------
-- 4.6 Work Cell Type Sync
-- -----------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION sync_work_cell_type_to_search_index()
RETURNS TRIGGER AS $$
DECLARE
  v_table_name TEXT;
BEGIN
  IF TG_OP = 'DELETE' THEN
    v_table_name := 'searchIndex_' || OLD."companyId";
    EXECUTE format('DELETE FROM %I WHERE "entityType" = $1 AND "entityId" = $2', v_table_name)
      USING 'workCellType', OLD.id;
    RETURN OLD;
  END IF;

  v_table_name := 'searchIndex_' || NEW."companyId";

  EXECUTE format('
    INSERT INTO %I ("entityType", "entityId", "title", "description", "link", "tags", "metadata")
    VALUES ($1, $2, $3, $4, $5, $6, $7)
    ON CONFLICT ("entityType", "entityId") DO UPDATE SET
      "title" = EXCLUDED."title",
      "description" = EXCLUDED."description",
      "tags" = EXCLUDED."tags",
      "metadata" = EXCLUDED."metadata",
      "updatedAt" = NOW()
  ', v_table_name) USING
    'workCellType',
    NEW.id,
    NEW.name,
    COALESCE(NEW.description, ''),
    '/x/resources/work-cells/' || NEW.id,
    ARRAY[CASE WHEN NEW.active THEN 'active' ELSE 'inactive' END],
    jsonb_build_object('quotingRate', NEW."quotingRate");

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- -----------------------------------------------------------------------------
-- 4.7 Job Sync
-- -----------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION sync_job_to_search_index()
RETURNS TRIGGER AS $$
DECLARE
  v_table_name TEXT;
  v_item_name TEXT;
  v_cust_name TEXT;
BEGIN
  IF TG_OP = 'DELETE' THEN
    v_table_name := 'searchIndex_' || OLD."companyId";
    EXECUTE format('DELETE FROM %I WHERE "entityType" = $1 AND "entityId" = $2', v_table_name)
      USING 'job', OLD.id;
    RETURN OLD;
  END IF;

  v_table_name := 'searchIndex_' || NEW."companyId";

  SELECT name INTO v_item_name FROM "item" WHERE id = NEW."itemId";
  SELECT name INTO v_cust_name FROM "customer" WHERE id = NEW."customerId";

  EXECUTE format('
    INSERT INTO %I ("entityType", "entityId", "title", "description", "link", "tags", "metadata")
    VALUES ($1, $2, $3, $4, $5, $6, $7)
    ON CONFLICT ("entityType", "entityId") DO UPDATE SET
      "title" = EXCLUDED."title",
      "description" = EXCLUDED."description",
      "tags" = EXCLUDED."tags",
      "metadata" = EXCLUDED."metadata",
      "updatedAt" = NOW()
  ', v_table_name) USING
    'job',
    NEW.id,
    NEW."jobId",
    COALESCE(v_item_name, '') || ' ' || COALESCE(v_cust_name, ''),
    '/x/job/' || NEW.id,
    ARRAY_REMOVE(ARRAY[NEW.status::TEXT, NEW."deadlineType"::TEXT], NULL),
    jsonb_build_object('quantity', NEW.quantity, 'dueDate', NEW."dueDate");

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- -----------------------------------------------------------------------------
-- 4.8 Purchase Order Sync
-- -----------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION sync_purchase_order_to_search_index()
RETURNS TRIGGER AS $$
DECLARE
  v_table_name TEXT;
  v_supp_name TEXT;
BEGIN
  IF TG_OP = 'DELETE' THEN
    v_table_name := 'searchIndex_' || OLD."companyId";
    EXECUTE format('DELETE FROM %I WHERE "entityType" = $1 AND "entityId" = $2', v_table_name)
      USING 'purchaseOrder', OLD.id;
    RETURN OLD;
  END IF;

  v_table_name := 'searchIndex_' || NEW."companyId";

  SELECT name INTO v_supp_name FROM "supplier" WHERE id = NEW."supplierId";

  EXECUTE format('
    INSERT INTO %I ("entityType", "entityId", "title", "description", "link", "tags", "metadata")
    VALUES ($1, $2, $3, $4, $5, $6, $7)
    ON CONFLICT ("entityType", "entityId") DO UPDATE SET
      "title" = EXCLUDED."title",
      "description" = EXCLUDED."description",
      "tags" = EXCLUDED."tags",
      "metadata" = EXCLUDED."metadata",
      "updatedAt" = NOW()
  ', v_table_name) USING
    'purchaseOrder',
    NEW.id,
    NEW."purchaseOrderId",
    COALESCE(v_supp_name, ''),
    '/x/purchase-order/' || NEW.id,
    ARRAY_REMOVE(ARRAY[NEW.status::TEXT, NEW.type::TEXT], NULL),
    jsonb_build_object('orderDate', NEW."orderDate", 'supplierReference', NEW."supplierReference");

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- -----------------------------------------------------------------------------
-- 4.9 Sales Invoice Sync
-- -----------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION sync_sales_invoice_to_search_index()
RETURNS TRIGGER AS $$
DECLARE
  v_table_name TEXT;
  v_cust_name TEXT;
BEGIN
  IF TG_OP = 'DELETE' THEN
    v_table_name := 'searchIndex_' || OLD."companyId";
    EXECUTE format('DELETE FROM %I WHERE "entityType" = $1 AND "entityId" = $2', v_table_name)
      USING 'salesInvoice', OLD.id;
    RETURN OLD;
  END IF;

  v_table_name := 'searchIndex_' || NEW."companyId";

  SELECT name INTO v_cust_name FROM "customer" WHERE id = NEW."customerId";

  EXECUTE format('
    INSERT INTO %I ("entityType", "entityId", "title", "description", "link", "tags", "metadata")
    VALUES ($1, $2, $3, $4, $5, $6, $7)
    ON CONFLICT ("entityType", "entityId") DO UPDATE SET
      "title" = EXCLUDED."title",
      "description" = EXCLUDED."description",
      "tags" = EXCLUDED."tags",
      "metadata" = EXCLUDED."metadata",
      "updatedAt" = NOW()
  ', v_table_name) USING
    'salesInvoice',
    NEW.id,
    NEW."invoiceId",
    COALESCE(v_cust_name, ''),
    '/x/invoicing/sales/' || NEW.id,
    ARRAY_REMOVE(ARRAY[NEW.status::TEXT], NULL),
    jsonb_build_object('totalAmount', NEW."totalAmount", 'dateDue', NEW."dateDue");

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- -----------------------------------------------------------------------------
-- 4.10 Purchase Invoice Sync
-- -----------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION sync_purchase_invoice_to_search_index()
RETURNS TRIGGER AS $$
DECLARE
  v_table_name TEXT;
  v_supp_name TEXT;
BEGIN
  IF TG_OP = 'DELETE' THEN
    v_table_name := 'searchIndex_' || OLD."companyId";
    EXECUTE format('DELETE FROM %I WHERE "entityType" = $1 AND "entityId" = $2', v_table_name)
      USING 'purchaseInvoice', OLD.id;
    RETURN OLD;
  END IF;

  v_table_name := 'searchIndex_' || NEW."companyId";

  SELECT name INTO v_supp_name FROM "supplier" WHERE id = NEW."supplierId";

  EXECUTE format('
    INSERT INTO %I ("entityType", "entityId", "title", "description", "link", "tags", "metadata")
    VALUES ($1, $2, $3, $4, $5, $6, $7)
    ON CONFLICT ("entityType", "entityId") DO UPDATE SET
      "title" = EXCLUDED."title",
      "description" = EXCLUDED."description",
      "tags" = EXCLUDED."tags",
      "metadata" = EXCLUDED."metadata",
      "updatedAt" = NOW()
  ', v_table_name) USING
    'purchaseInvoice',
    NEW.id,
    NEW."invoiceId",
    COALESCE(v_supp_name, ''),
    '/x/invoicing/purchasing/' || NEW.id,
    ARRAY_REMOVE(ARRAY[NEW.status::TEXT], NULL),
    jsonb_build_object('totalAmount', NEW."totalAmount", 'dateDue', NEW."dateDue");

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================================================
-- PART 5: Create Entity Table Triggers
-- =============================================================================

-- Employee triggers
CREATE TRIGGER sync_employee_search_insert
  AFTER INSERT ON "employee"
  FOR EACH ROW EXECUTE FUNCTION sync_employee_to_search_index();

CREATE TRIGGER sync_employee_search_update
  AFTER UPDATE ON "employee"
  FOR EACH ROW EXECUTE FUNCTION sync_employee_to_search_index();

CREATE TRIGGER sync_employee_search_delete
  AFTER DELETE ON "employee"
  FOR EACH ROW EXECUTE FUNCTION sync_employee_to_search_index();

-- Customer triggers
CREATE TRIGGER sync_customer_search_insert
  AFTER INSERT ON "customer"
  FOR EACH ROW EXECUTE FUNCTION sync_customer_to_search_index();

CREATE TRIGGER sync_customer_search_update
  AFTER UPDATE ON "customer"
  FOR EACH ROW EXECUTE FUNCTION sync_customer_to_search_index();

CREATE TRIGGER sync_customer_search_delete
  AFTER DELETE ON "customer"
  FOR EACH ROW EXECUTE FUNCTION sync_customer_to_search_index();

-- Supplier triggers
CREATE TRIGGER sync_supplier_search_insert
  AFTER INSERT ON "supplier"
  FOR EACH ROW EXECUTE FUNCTION sync_supplier_to_search_index();

CREATE TRIGGER sync_supplier_search_update
  AFTER UPDATE ON "supplier"
  FOR EACH ROW EXECUTE FUNCTION sync_supplier_to_search_index();

CREATE TRIGGER sync_supplier_search_delete
  AFTER DELETE ON "supplier"
  FOR EACH ROW EXECUTE FUNCTION sync_supplier_to_search_index();

-- Item triggers
CREATE TRIGGER sync_item_search_insert
  AFTER INSERT ON "item"
  FOR EACH ROW EXECUTE FUNCTION sync_item_to_search_index();

CREATE TRIGGER sync_item_search_update
  AFTER UPDATE ON "item"
  FOR EACH ROW EXECUTE FUNCTION sync_item_to_search_index();

CREATE TRIGGER sync_item_search_delete
  AFTER DELETE ON "item"
  FOR EACH ROW EXECUTE FUNCTION sync_item_to_search_index();

-- Equipment Type triggers
CREATE TRIGGER sync_equipment_type_search_insert
  AFTER INSERT ON "equipmentType"
  FOR EACH ROW EXECUTE FUNCTION sync_equipment_type_to_search_index();

CREATE TRIGGER sync_equipment_type_search_update
  AFTER UPDATE ON "equipmentType"
  FOR EACH ROW EXECUTE FUNCTION sync_equipment_type_to_search_index();

CREATE TRIGGER sync_equipment_type_search_delete
  AFTER DELETE ON "equipmentType"
  FOR EACH ROW EXECUTE FUNCTION sync_equipment_type_to_search_index();

-- Work Cell Type triggers
CREATE TRIGGER sync_work_cell_type_search_insert
  AFTER INSERT ON "workCellType"
  FOR EACH ROW EXECUTE FUNCTION sync_work_cell_type_to_search_index();

CREATE TRIGGER sync_work_cell_type_search_update
  AFTER UPDATE ON "workCellType"
  FOR EACH ROW EXECUTE FUNCTION sync_work_cell_type_to_search_index();

CREATE TRIGGER sync_work_cell_type_search_delete
  AFTER DELETE ON "workCellType"
  FOR EACH ROW EXECUTE FUNCTION sync_work_cell_type_to_search_index();

-- Job triggers
CREATE TRIGGER sync_job_search_insert
  AFTER INSERT ON "job"
  FOR EACH ROW EXECUTE FUNCTION sync_job_to_search_index();

CREATE TRIGGER sync_job_search_update
  AFTER UPDATE ON "job"
  FOR EACH ROW EXECUTE FUNCTION sync_job_to_search_index();

CREATE TRIGGER sync_job_search_delete
  AFTER DELETE ON "job"
  FOR EACH ROW EXECUTE FUNCTION sync_job_to_search_index();

-- Purchase Order triggers
CREATE TRIGGER sync_purchase_order_search_insert
  AFTER INSERT ON "purchaseOrder"
  FOR EACH ROW EXECUTE FUNCTION sync_purchase_order_to_search_index();

CREATE TRIGGER sync_purchase_order_search_update
  AFTER UPDATE ON "purchaseOrder"
  FOR EACH ROW EXECUTE FUNCTION sync_purchase_order_to_search_index();

CREATE TRIGGER sync_purchase_order_search_delete
  AFTER DELETE ON "purchaseOrder"
  FOR EACH ROW EXECUTE FUNCTION sync_purchase_order_to_search_index();

-- Sales Invoice triggers
CREATE TRIGGER sync_sales_invoice_search_insert
  AFTER INSERT ON "salesInvoice"
  FOR EACH ROW EXECUTE FUNCTION sync_sales_invoice_to_search_index();

CREATE TRIGGER sync_sales_invoice_search_update
  AFTER UPDATE ON "salesInvoice"
  FOR EACH ROW EXECUTE FUNCTION sync_sales_invoice_to_search_index();

CREATE TRIGGER sync_sales_invoice_search_delete
  AFTER DELETE ON "salesInvoice"
  FOR EACH ROW EXECUTE FUNCTION sync_sales_invoice_to_search_index();

-- Purchase Invoice triggers
CREATE TRIGGER sync_purchase_invoice_search_insert
  AFTER INSERT ON "purchaseInvoice"
  FOR EACH ROW EXECUTE FUNCTION sync_purchase_invoice_to_search_index();

CREATE TRIGGER sync_purchase_invoice_search_update
  AFTER UPDATE ON "purchaseInvoice"
  FOR EACH ROW EXECUTE FUNCTION sync_purchase_invoice_to_search_index();

CREATE TRIGGER sync_purchase_invoice_search_delete
  AFTER DELETE ON "purchaseInvoice"
  FOR EACH ROW EXECUTE FUNCTION sync_purchase_invoice_to_search_index();

-- =============================================================================
-- PART 6: Create Population Function
-- =============================================================================

CREATE OR REPLACE FUNCTION populate_company_search_index(p_company_id TEXT)
RETURNS VOID AS $$
DECLARE
  v_table_name TEXT := 'searchIndex_' || p_company_id;
BEGIN
  -- Populate employees
  EXECUTE format('
    INSERT INTO %I ("entityType", "entityId", "title", "link", "tags", "metadata")
    SELECT
      ''employee'',
      e.id,
      COALESCE(u."fullName", ''''),
      ''/x/person/'' || e.id,
      ARRAY_REMOVE(ARRAY[et.name], NULL),
      jsonb_build_object(''active'', e.active)
    FROM "employee" e
    INNER JOIN "user" u ON u.id = e.id
    LEFT JOIN "employeeType" et ON et.id = e."employeeTypeId"
    WHERE e."companyId" = $1 AND e.active = true
    ON CONFLICT ("entityType", "entityId") DO UPDATE SET
      "title" = EXCLUDED."title",
      "tags" = EXCLUDED."tags",
      "metadata" = EXCLUDED."metadata",
      "updatedAt" = NOW()
  ', v_table_name) USING p_company_id;

  -- Populate customers
  EXECUTE format('
    INSERT INTO %I ("entityType", "entityId", "title", "link", "tags", "metadata")
    SELECT
      ''customer'',
      c.id,
      c.name,
      ''/x/customer/'' || c.id,
      ARRAY_REMOVE(ARRAY[ct.name, cs.name], NULL),
      jsonb_build_object(''taxId'', c."taxId")
    FROM "customer" c
    LEFT JOIN "customerType" ct ON ct.id = c."customerTypeId"
    LEFT JOIN "customerStatus" cs ON cs.id = c."customerStatusId"
    WHERE c."companyId" = $1
    ON CONFLICT ("entityType", "entityId") DO UPDATE SET
      "title" = EXCLUDED."title",
      "tags" = EXCLUDED."tags",
      "metadata" = EXCLUDED."metadata",
      "updatedAt" = NOW()
  ', v_table_name) USING p_company_id;

  -- Populate suppliers
  EXECUTE format('
    INSERT INTO %I ("entityType", "entityId", "title", "link", "tags", "metadata")
    SELECT
      ''supplier'',
      s.id,
      s.name,
      ''/x/supplier/'' || s.id,
      ARRAY_REMOVE(ARRAY[st.name, ss.name], NULL),
      jsonb_build_object(''taxId'', s."taxId")
    FROM "supplier" s
    LEFT JOIN "supplierType" st ON st.id = s."supplierTypeId"
    LEFT JOIN "supplierStatus" ss ON ss.id = s."supplierStatusId"
    WHERE s."companyId" = $1
    ON CONFLICT ("entityType", "entityId") DO UPDATE SET
      "title" = EXCLUDED."title",
      "tags" = EXCLUDED."tags",
      "metadata" = EXCLUDED."metadata",
      "updatedAt" = NOW()
  ', v_table_name) USING p_company_id;

  -- Populate items
  EXECUTE format('
    INSERT INTO %I ("entityType", "entityId", "title", "description", "link", "tags", "metadata")
    SELECT
      ''item'',
      i.id,
      i."readableId",
      i.name || '' '' || COALESCE(i.description, ''''),
      CASE i.type
        WHEN ''Part'' THEN ''/x/part/'' || i.id
        WHEN ''Service'' THEN ''/x/service/'' || i.id
        WHEN ''Tool'' THEN ''/x/tool/'' || i.id
        WHEN ''Consumable'' THEN ''/x/consumable/'' || i.id
        WHEN ''Material'' THEN ''/x/material/'' || i.id
        WHEN ''Fixture'' THEN ''/x/fixture/'' || i.id
        ELSE ''/x/part/'' || i.id
      END,
      ARRAY_REMOVE(ARRAY[i.type::TEXT, i."replenishmentSystem"::TEXT], NULL),
      jsonb_build_object(''active'', i.active, ''blocked'', i.blocked)
    FROM "item" i
    WHERE i."companyId" = $1
    ON CONFLICT ("entityType", "entityId") DO UPDATE SET
      "title" = EXCLUDED."title",
      "description" = EXCLUDED."description",
      "link" = EXCLUDED."link",
      "tags" = EXCLUDED."tags",
      "metadata" = EXCLUDED."metadata",
      "updatedAt" = NOW()
  ', v_table_name) USING p_company_id;

  -- Populate equipment types
  EXECUTE format('
    INSERT INTO %I ("entityType", "entityId", "title", "description", "link", "tags", "metadata")
    SELECT
      ''equipmentType'',
      et.id,
      et.name,
      COALESCE(et.description, ''''),
      ''/x/resources/equipment/'' || et.id,
      ARRAY[CASE WHEN et.active THEN ''active'' ELSE ''inactive'' END],
      jsonb_build_object(''setupHours'', et."setupHours")
    FROM "equipmentType" et
    WHERE et."companyId" = $1
    ON CONFLICT ("entityType", "entityId") DO UPDATE SET
      "title" = EXCLUDED."title",
      "description" = EXCLUDED."description",
      "tags" = EXCLUDED."tags",
      "metadata" = EXCLUDED."metadata",
      "updatedAt" = NOW()
  ', v_table_name) USING p_company_id;

  -- Populate work cell types
  EXECUTE format('
    INSERT INTO %I ("entityType", "entityId", "title", "description", "link", "tags", "metadata")
    SELECT
      ''workCellType'',
      wct.id,
      wct.name,
      COALESCE(wct.description, ''''),
      ''/x/resources/work-cells/'' || wct.id,
      ARRAY[CASE WHEN wct.active THEN ''active'' ELSE ''inactive'' END],
      jsonb_build_object(''quotingRate'', wct."quotingRate")
    FROM "workCellType" wct
    WHERE wct."companyId" = $1
    ON CONFLICT ("entityType", "entityId") DO UPDATE SET
      "title" = EXCLUDED."title",
      "description" = EXCLUDED."description",
      "tags" = EXCLUDED."tags",
      "metadata" = EXCLUDED."metadata",
      "updatedAt" = NOW()
  ', v_table_name) USING p_company_id;

  -- Populate jobs
  EXECUTE format('
    INSERT INTO %I ("entityType", "entityId", "title", "description", "link", "tags", "metadata")
    SELECT
      ''job'',
      j.id,
      j."jobId",
      COALESCE(i.name, '''') || '' '' || COALESCE(c.name, ''''),
      ''/x/job/'' || j.id,
      ARRAY_REMOVE(ARRAY[j.status::TEXT, j."deadlineType"::TEXT], NULL),
      jsonb_build_object(''quantity'', j.quantity, ''dueDate'', j."dueDate")
    FROM "job" j
    LEFT JOIN "item" i ON i.id = j."itemId"
    LEFT JOIN "customer" c ON c.id = j."customerId"
    WHERE j."companyId" = $1
    ON CONFLICT ("entityType", "entityId") DO UPDATE SET
      "title" = EXCLUDED."title",
      "description" = EXCLUDED."description",
      "tags" = EXCLUDED."tags",
      "metadata" = EXCLUDED."metadata",
      "updatedAt" = NOW()
  ', v_table_name) USING p_company_id;

  -- Populate purchase orders
  EXECUTE format('
    INSERT INTO %I ("entityType", "entityId", "title", "description", "link", "tags", "metadata")
    SELECT
      ''purchaseOrder'',
      po.id,
      po."purchaseOrderId",
      COALESCE(s.name, ''''),
      ''/x/purchase-order/'' || po.id,
      ARRAY_REMOVE(ARRAY[po.status::TEXT, po.type::TEXT], NULL),
      jsonb_build_object(''orderDate'', po."orderDate", ''supplierReference'', po."supplierReference")
    FROM "purchaseOrder" po
    LEFT JOIN "supplier" s ON s.id = po."supplierId"
    WHERE po."companyId" = $1
    ON CONFLICT ("entityType", "entityId") DO UPDATE SET
      "title" = EXCLUDED."title",
      "description" = EXCLUDED."description",
      "tags" = EXCLUDED."tags",
      "metadata" = EXCLUDED."metadata",
      "updatedAt" = NOW()
  ', v_table_name) USING p_company_id;

  -- Populate sales invoices
  EXECUTE format('
    INSERT INTO %I ("entityType", "entityId", "title", "description", "link", "tags", "metadata")
    SELECT
      ''salesInvoice'',
      si.id,
      si."invoiceId",
      COALESCE(c.name, ''''),
      ''/x/invoicing/sales/'' || si.id,
      ARRAY_REMOVE(ARRAY[si.status::TEXT], NULL),
      jsonb_build_object(''totalAmount'', si."totalAmount", ''dateDue'', si."dateDue")
    FROM "salesInvoice" si
    LEFT JOIN "customer" c ON c.id = si."customerId"
    WHERE si."companyId" = $1
    ON CONFLICT ("entityType", "entityId") DO UPDATE SET
      "title" = EXCLUDED."title",
      "description" = EXCLUDED."description",
      "tags" = EXCLUDED."tags",
      "metadata" = EXCLUDED."metadata",
      "updatedAt" = NOW()
  ', v_table_name) USING p_company_id;

  -- Populate purchase invoices
  EXECUTE format('
    INSERT INTO %I ("entityType", "entityId", "title", "description", "link", "tags", "metadata")
    SELECT
      ''purchaseInvoice'',
      pi.id,
      pi."invoiceId",
      COALESCE(s.name, ''''),
      ''/x/invoicing/purchasing/'' || pi.id,
      ARRAY_REMOVE(ARRAY[pi.status::TEXT], NULL),
      jsonb_build_object(''totalAmount'', pi."totalAmount", ''dateDue'', pi."dateDue")
    FROM "purchaseInvoice" pi
    LEFT JOIN "supplier" s ON s.id = pi."supplierId"
    WHERE pi."companyId" = $1
    ON CONFLICT ("entityType", "entityId") DO UPDATE SET
      "title" = EXCLUDED."title",
      "description" = EXCLUDED."description",
      "tags" = EXCLUDED."tags",
      "metadata" = EXCLUDED."metadata",
      "updatedAt" = NOW()
  ', v_table_name) USING p_company_id;

  -- Update registry
  UPDATE "searchIndexRegistry"
  SET "lastRebuiltAt" = NOW()
  WHERE "companyId" = p_company_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================================================
-- PART 7: Create Search Indexes for Existing Companies and Populate Data
-- =============================================================================

DO $$
DECLARE
  company_record RECORD;
BEGIN
  FOR company_record IN SELECT id FROM "company"
  LOOP
    PERFORM create_company_search_index(company_record.id);
    PERFORM populate_company_search_index(company_record.id);
  END LOOP;
END $$;
